## Настройка и использование pre-commit хуков с Husky и Commitizen

**Pre-commit** хуки помогают автоматизировать процесс проверки и форматирования кода перед коммитом, обеспечивая соблюдение кодового стиля и других стандартов качества.

**Шаг 1: Установка зависимостей.** Первым шагом является установка всех необходимых зависимостей. Это можно сделать, выполнив следующую команду в корневой директории проекта:

```
npm run prepare-services
```

**Шаг 2: Установка Commitizen глобально.** Commitizen - это инструмент, который помогает создавать правильно отформатированные сообщения коммитов. Установите его глобально, используя следующую команду:

```
npm i -g commitizen
```

**Шаг 3: Инициализация Husky.** Husky - это инструмент для работы с git hooks. Инициализируйте Husky, выполнив следующую команду:

```
npm run prepare
```

**Шаг 4: Совершение коммита с помощью Commitizen.** Теперь, когда все готово, вы можете сделать коммит, используя Commitizen. Это обеспечит форматирование ваших сообщений коммитов в соответствии с выбранным вами стандартом. Введите следующую команду и следуйте появившимся инструкциям:

```
git cz
```

Подробное описание после введения команды git cz

**1. Выберите тип изменения, которое вы фиксируете (Select the type of change that you're committing):**

- **feat** (Feature): Новая функциональность или особенность, добавленная в проект.
- **fix** (Bug Fix): Исправление ошибки или бага в проекте.
- **docs** (Documentation): Изменения, касающиеся только документации проекта.
- **style** (Style): Изменения, которые не влияют на смысл кода (например, пробелы, форматирование, отсутствующие точки с запятой и т.д.).
- **refactor** (Refactoring): Изменение кода, которое не исправляет ошибку и не добавляет функциональности.
- **perf** (Performance): Изменение кода, которое улучшает производительность.
- **test** (Tests): Добавление отсутствующих тестов или корректировка существующих тестов.
- **build** (Build System): Изменения, которые влияют на систему сборки или внешние зависимости (например, области применения: gulp, broccoli, npm).
- **ci** (Continuous Integration): Изменения в файлах и скриптах конфигурации CI (например, области применения: Travis, Circle, BrowserStack, SauceLabs).
- **chore** (Chores): Другие изменения, которые не модифицируют исходные файлы или тестовые файлы.
- **revert** (Revert): Возврат предыдущего коммита.

**2. Область изменения (Scope of change):** Это может быть название компонента, файла, модуля или любой другой логической части проекта, которую затрагивают ваши изменения. Это помогает другим разработчикам быстро понять, какая часть кода была изменена в этом коммите. Напрмиер:

- Если вы обновили документацию для конкретного компонента, например, LoginComponent, вы можете ввести LoginComponent в качестве области изменения.
- Если вы обновили README файл, вы можете ввести README в качестве области изменения.
- Пропуск (Skip): Если область изменения не применима или не важна для данного коммита, вы можете пропустить этот шаг, нажав клавишу Enter.

**3. Краткое описание изменений (Short description of the change):** Это сообщение поможет другим разработчикам понять, что было сделано в этом конкретном коммите, не заглядывая в код. Это сообщение должно быть формулировано в императивном наклонении и должно ясно и точно описывать суть выполненных вами изменений.

- Императивное наклонение (Imperative tense): Сообщение коммита должно быть написано в императивном наклонении, что является стандартной практикой для сообщений коммитов. Это значит, что сообщение должно начинаться с глагола в повелительном наклонении, например, "Добавить", "Изменить", "Исправить" и так далее.
- Commitizen устанавливает ограничение в 82 символа для этого описания, чтобы сообщения коммитов были короткими и лаконичными.

**4. Предоставьте более подробное описание изменения (Provide a longer description of the change):** Этот шаг в процессе создания коммита предлагает вам предоставить более подробное описание изменений. Это поле является необязательным, и вы можете пропустить его, нажав Enter, если считаете, что краткое описание достаточно информативно. Это может включать в себя технические детали, ссылки на связанные задачи или запросы на вытягивание, или другую информацию, которая может быть полезной для других разработчиков или для будущего вас

**5. Вносят ли ваши изменения какие-либо обратно несовместимые изменения в проект (Are there any breaking changes?):** Этот вопрос в процессе создания коммита спрашивает, вносят ли ваши изменения какие-либо обратно несовместимые изменения в проект. Обратно несовместимые изменения - это изменения, которые могут привести к сбоям или ошибкам в существующем коде, если другие разработчики или системы используют старую версию вашего кода. Примеры включают удаление функций, изменение сигнатур функций или изменение формата возвращаемых данных.

- Если ваши изменения включают обратно несовместимые изменения, введите y (да).
- Если ваши изменения не включают обратно несовместимые изменения, введите N (нет).

**6.Влияют ли ваши изменения на какие-либо открытые вопросы или задачи в вашем проекте (Does this change affect any open issues?):** Этот вопрос связан с тем, влияют ли ваши изменения на какие-либо открытые вопросы или задачи в вашем проекте. Он может быть связан с системой отслеживания задач, такой как Jira или GitHub Issues, которая используется в вашем проекте для отслеживания задач и проблем.

- Если ваш коммит адресует или влияет на какие-либо открытые вопросы, введите y (да).
- Если ваш коммит не влияет на какие-либо открытые вопросы, введите N (нет).

**7.После того как сообщение коммита было создано и сохранено, Husky начинает свою работу.**

- Husky запускает commitlint, который проверяет ваше сообщение коммита на соответствие определенным правилам. Если сообщение коммита не соответствует этим правилам, commitlint вернет ошибку, и коммит будет отклонен.

```
commitlint.config.js # Правила для коммитов
```

- Затем Husky запускает lint-staged, который запускает линтеры на измененных файлах. lint-staged может автоматически исправлять ошибки или предлагать исправления, в зависимости от вашей конфигурации.
- Если все хуки успешно прошли, и нет ошибок, то ваш коммит будет завершен, и изменения будут зарегистрированы в вашем репозитории git.

---

## MongoDb работает с транзакциями, поэтому необходимо установить

**Шаг 1:** Найдите файл конфигурации MongoDB на вашем устройстве. Обычно он называется **mongod.conf.**

**Шаг 2:** Добавьте следующие строки в ваш файл конфигурации:

```
replication:
  replSetName: "rs0"  # имя набора реплик
```

**Шаг 3:** Сохраните и закройте файл конфигурации.

**Шаг 4:** Перезапустите MongoDB с обновленной конфигурацией. В зависимости от вашей операционной системы выполните одну из следующих команд в терминале:

- Windows:

```
mongod --config "путь\до\вашего\mongod.conf" --install
```

- MacOS:

```
brew services start mongodb-community --config=/путь/до/вашего/mongod.conf
```

**Шаг 5:** Откройте MongoDB shell, выполнив следующую команду в терминале:

```
mongo
```

**Шаг 6:** После успешного подключения инициализируйте репликацию, введя следующую команду в MongoDB shell:

```
rs.initiate()
```

**Шаг 7:** Проверьте статус репликации, введя следующую команду в MongoDB shell:

```
rs.status()
```

**Шаг 8:** В файле с переменными среды (env) вашего проекта добавьте следующую строку:

```
DB_REPLICATION_SET=name replication set
```
### Redis
Для работы чатов, а в будущем для кеширования запросов в проекте используется БД Redis. 

**Шаг 1: Установка.**
Установите Redis локально [Ссылка на иструкции по установке на разные ОС](https://redis.io/docs/install/install-redis/)

**Шаг 2: Запуск.**
Сначала запустите сервис с Redis
```
sudo service redis-server start
```

После запуска ведите команду в терминале 
```
redis-cli
```
**Шаг 3: Проверка запуска.**
Введите команду ping в терминале вы должны увидеть ответ PONG
```
redis 127.0.0.1:6379> ping
PONG
```
**Шаг 4: Режим отладки.**
Для отладки введите команду monitor в терминале
```
redis 127.0.0.1:6379> monitor
OK
```
### RabbitMQ
Для работы чатов, рассылок и прочих задач требующих ресурсы используется обработик очереди задач RabbitMQ

Для Windows можно установить через Chocolate. Так же вам потребуется установить язык программирования Erlang.  На все вопросы отвечайте утвердительно, установится так же Erlang.
```
choco install rabbitmq
```
Для остальных [Ссылка на иструкции по установке на разные ОС](https://www.rabbitmq.com/docs/download)

## Обработка ошибок и логгирование

Все обьявленные через catch ошибки перехватываются глобально через кастомный фильтр исключений [utils/globalFilterHTTP.expection](https://docs.nestjs.com/exception-filters#exception-filters-1).
Неучтенные ошибки перехватываются в main.ts через process.

Логгирование с помощью пакета [nest-winston](https://www.npmjs.com/package/nest-winston) добавлена фабрика __loggerFactory.ts__ логгер в папке utils.

Для добавления по необходимости логгера в разные места проекта: через класс из пакета @nestjs/common - Logger.error('ошибки'),

## Использование AppClusterService для Кластеризации

### Описание

`AppClusterService` — это класс, предназначенный для оптимизации использования ресурсов многоядерных систем в Node.js приложениях с помощью кластеризации. Он позволяет легко создавать несколько экземпляров Node.js (кластеров), работающих параллельно на разных ядрах процессора, что повышает производительность и надёжность приложения.

### Как это работает

Класс использует модуль `cluster` Node.js для создания "главного" процесса (primary), который затем порождает несколько "рабочих" процессов (workers) — кластеров. Каждый кластер выполняет одинаковый код и работает на отдельном ядре процессора. Это позволяет более эффективно распределять нагрузку и повышает отказоустойчивость системы, так как при сбое одного кластера, остальные продолжают работать, и проблемный кластер может быть перезапущен.

### Пример использования

Для использования `AppClusterService`, необходимо вызвать его метод `clusterize`, передав в него функцию, которую вы хотите выполнить в каждом кластере, и, опционально, количество ядер, которое вы хотите использовать.

```
import { AppClusterService } from './path/to/AppClusterService';

AppClusterService.clusterize(() => {
  // Ваш код, который будет исполняться в каждом кластере
}, numCores);
```
### Запуск в режиме разработки
**Шаг 1: Подготовка первого запуска.**

Сначала подготовьте микросервисы к работе и установите зависимости в проекте. В корне проекта введите в командной строке команду и дождитесь её завершения.
```
npm run prepare-services
```
Это установит все пакеты в микросервисах для работы бэкенда, чатов и воркера для обработки событий в Redis в будущем.

**Шаг 2: Запуск.**

Если вам нужно работать с чатом или воркером с redis, то перед запуском бэкенда запутсите сервисы

__Worker__
```
npm run worker
```
Эта команда запустит сервис для работы с событиями в Redis а так же для обработки событий на моковом сервере с моковым чатом и API.

__MockServer__
```
npm run mock
```
Это запустит моковый стенд для обработки событий по WS мокового чата и отправки событий в Redis. 

__Бэкенд часть проекта__ 
Запустит проект и позволит видеть изменения которые вы делаете в проекте в реальном времени
```
npm run start:dev
```
### Запуск в режиме production
```
docker-compose -f docker-compose.yml --env-file .env up -d
```
Развернет все приложение месте с микросервисами в контейнерах, запустит их в нужном порядке и вы сможете отправлять запросы на контейнера с номерами портов указанных в env файле.